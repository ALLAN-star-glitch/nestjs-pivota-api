//The JwtStrategy is for validating those tokens generated by jwt service when they are sent in requests.



import { Injectable, UnauthorizedException } from '@nestjs/common'; 
import { PassportStrategy } from '@nestjs/passport'; 
import { Strategy, ExtractJwt } from 'passport-jwt'; 
import { PrismaService } from 'src/auth/prisma.service'; 
import { JwtPayload } from './jwt-payload.interface'; 

// Injectable decorator to mark this as a service that can be injected
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  // Constructor receives PrismaService for DB interactions
  constructor(private readonly prisma: PrismaService) {
    // Super call to initialize Passport strategy with JWT options
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Extract JWT from the Bearer token in the header
      ignoreExpiration: false, // Don't ignore expiration (validate JWT expiration)
      secretOrKey: process.env.JWT_SECRET || 'default-secret', // Secret key for verifying JWT
    });
    
    console.log("JWT SECRET",process.env.JWT_SECRET);

  }

  // The validate method is called after the JWT is extracted and verified
  async validate(payload: JwtPayload) {
    // The JWT payload should contain email, firstName, plan, and roles
    const { email, firstName, plan, roles } = payload;

    // Find the user associated with the email from the JWT payload
    const user = await this.prisma.user.findUnique({
      where: { email },
      include: { roles: true }, // Also retrieve associated roles of the user
    });

    // If no user found, throw an UnauthorizedException
    if (!user) {
      throw new UnauthorizedException('User not found');
    }

    // Optionally: Validate roles or other specific conditions based on your app's logic
    if (user.firstName !== firstName) {
      throw new UnauthorizedException('JWT payload firstName mismatch');
    }

    if (user.plan !== plan) {
      throw new UnauthorizedException('JWT payload plan mismatch');
    }

    // If the user is found and data matches, return an object with user details
    // The returned object will be attached to the request object as req.user
    return { userId: user.id, email: user.email, roles: user.roles };
  }
}
